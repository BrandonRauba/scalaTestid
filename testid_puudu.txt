** Test2:
extension [T](xs: List[T])
  def second = xs.tail.head
Testida, kas second on aeglasem kui _.tail.head.


class Logarithm(d:Double)
	def v : Double = math.log(d)



* Union Types
case class UserName(name: String)
case class Password(hash: Hash)

def help(id: UserName | Password) =
  val user = id match
    case UserName(name) => lookupName(name)
    case Password(hash) => lookupPassword(hash)
vs.
def help(id: Either[UserName, Password]) =
  val user = id match
    case Left(UserName(name)) => lookupName(name)
    case Right(Password(hash)) => lookupPassword(hash)


*Dependent Function Types
trait Entry { type Key; val key: Key }

def extractKey(e: Entry): e.Key = e.key
val extractor: (e: Entry) => e.Key = extractKey
meetodi sees kutsuda extractor
v.s.
meetodi sees kutsuda extractKey
v.s.
kutsuda:
val extractor: (e: Entry) => Any = _.key



* Polymorphic Function Types
enum Expr[A]:
  case Var(name: String)
  case Apply[A, B](fun: Expr[B => A], arg: Expr[B]) extends Expr[A]
def mapSubexpressions[A](e: Expr[A])(f: [B] => Expr[B] => Expr[B]): Expr[A] =
  e match
    case Apply(fun, arg) => Apply(f(fun), f(arg))
    case Var(n) => Var(n)
val e0 = Apply(Var("f"), Var("a"))
val e1 = mapSubexpressions(e0)(
  [B] => (se: Expr[B]) => Apply(Var[B => B]("wrap"), se))
vs.
enum Expr:
  case Var(name: String)
  case Apply(fun: Expr, arg: Expr) extends Expr
def mapSubexpressions[A](e: Expr)(f: Expr => Expr): Expr =
  e match
    case Apply(fun, arg) => Apply(f(fun), f(arg))
    case Var(n) => Var(n)
val e0 = Apply(Var("f"), Var("a"))
val e1 = mapSubexpressions(e0)(
  (se: Expr) => Apply(Var("wrap"), se))



